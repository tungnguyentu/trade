from abc import ABC, abstractmethod
import pandas as pd
from datetime import datetime
from app.indicators.technical_indicators import TechnicalIndicators
from app.utils.logger import get_logger

logger = get_logger()

class BaseStrategy(ABC):
    def __init__(self, symbol, timeframes=None):
        self.symbol = symbol
        self.timeframes = timeframes or ['1m', '5m', '15m', '1h', '4h']
        self.indicators = TechnicalIndicators()
        self.data = {}
        self.trade_signals = []
        self.name = "BaseStrategy"
        
    def prepare_data(self, data_dict):
        """
        Prepare data for strategy analysis
        
        Args:
            data_dict (dict): Dictionary with timeframe as key and DataFrame as value
            
        Returns:
            dict: Dictionary with prepared data for each timeframe
        """
        self.data = {}
        try:
            for timeframe, df in data_dict.items():
                if timeframe not in self.timeframes:
                    continue
                    
                # Add technical indicators
                prepared_df = TechnicalIndicators.add_all_indicators(df.copy())
                self.data[timeframe] = prepared_df
                
            return self.data
        except Exception as e:
            logger.error(f"Error preparing data for {self.name}: {e}")
            return {}
    
    @abstractmethod
    def generate_signals(self):
        """
        Generate trading signals
        
        Returns:
            dict: Signal information
        """
        pass
    
    @abstractmethod
    def should_enter_trade(self):
        """
        Check if strategy should enter a trade
        
        Returns:
            tuple: (bool, dict) - (should_enter, signal_data)
        """
        pass
    
    @abstractmethod
    def should_exit_trade(self, entry_price, current_position):
        """
        Check if strategy should exit a trade
        
        Args:
            entry_price (float): Entry price
            current_position (dict): Current position information
            
        Returns:
            tuple: (bool, str) - (should_exit, reason)
        """
        pass
    
    def calculate_stop_loss(self, entry_price, is_long=True):
        """
        Calculate stop loss price
        
        Args:
            entry_price (float): Entry price
            is_long (bool): Whether position is long
            
        Returns:
            float: Stop loss price
        """
        # Default implementation - override in specific strategies
        if is_long:
            return entry_price * 0.98  # 2% below entry for long
        else:
            return entry_price * 1.02  # 2% above entry for short
    
    def calculate_take_profit(self, entry_price, is_long=True):
        """
        Calculate take profit price
        
        Args:
            entry_price (float): Entry price
            is_long (bool): Whether position is long
            
        Returns:
            float: Take profit price
        """
        # Default implementation - override in specific strategies
        if is_long:
            return entry_price * 1.03  # 3% above entry for long
        else:
            return entry_price * 0.97  # 3% below entry for short
    
    def get_signal_reasoning(self, signal_data):
        """
        Generate human-readable reasoning for a signal
        
        Args:
            signal_data (dict): Signal data
            
        Returns:
            str: Signal reasoning text
        """
        # Default implementation - override in specific strategies
        return f"Signal generated by {self.name} strategy."
    
    def _timestamp_to_string(self, timestamp):
        """Convert timestamp to string format"""
        if isinstance(timestamp, pd.Timestamp):
            return timestamp.strftime('%Y-%m-%d %H:%M:%S')
        return str(timestamp) 